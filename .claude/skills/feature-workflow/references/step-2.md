# Step 2: 시스템 설계

> **컨텍스트 경계**
> 이 Step은 독립적인 설계 세션입니다. 이전 대화 맥락을 배제하고 아래 지시사항만 따르세요.
> 이렇게 하는 이유: Step 1 분석 결과에만 기반하여 객관적인 설계를 도출해야 합니다.

---

## 규칙 로드 (필수)

**이 Step을 시작하기 전에 다음 규칙을 로드하세요:**

1. **규칙 인덱스 읽기**: [assets/rules/AGENTS.md](../assets/rules/AGENTS.md)
2. **필수 규칙 로드**: `MUST/workflow-rule.md` (항상)
3. **도메인 규칙 확인**: 설계 대상에 따라 동적 로드
   - 예: React 컴포넌트 설계 → `react/AGENTS.md`
   - 예: API 설계 → `api/AGENTS.md`
   - 예: 테스트 전략 → `testing/AGENTS.md`

**빠른 체크:**

```
□ MUST/workflow-rule.md 로드함
□ Step 2 입력 파일: 10-output-plan.md 존재 확인
□ status.yaml에서 Step 1 completed 확인
```

---

## 역할 그룹 정의

시스템 설계, 아키텍처, 테스트 전략에 전문성을 가진 **System Design 전문가 그룹**이 다음 관점에서 설계를 수행한다고 시뮬레이션하세요:

| 관점                  | 분석 초점                                          |
| --------------------- | -------------------------------------------------- |
| **아키텍트**          | 컴포넌트 구조, 데이터 흐름, 인터페이스 설계        |
| **테스트 전략가**     | 테스트 경계, Mock 전략, 커버리지 목표              |
| **코드베이스 분석가** | 기존 패턴 파악, 일관성 유지, 재사용 가능 코드 식별 |
| **구현 계획자**       | 파일별 구현 순서, 의존성 관리, 작업 분해           |

각 관점의 분석 결과를 종합하여 LLM이 구현 가능한 수준의 설계 문서를 도출합니다.

## 책임

1. **Step 1 입력 반영**: 분석 결과(기술적 결정, 갭 분석, 테스트 시나리오)를 설계에 반영합니다.
2. **아키텍처 설계**: 컴포넌트 구조, 데이터 흐름, 인터페이스를 정의합니다.
3. **테스트 전략 수립**: Step 1의 테스트 시나리오를 구현 전략으로 변환합니다.
4. **구현 계획 작성**: LLM이 따를 수 있는 파일별 구현 순서를 정의합니다.
5. **코드 패턴 가이드**: 기존 코드 패턴을 분석하고 따라야 할 패턴을 명시합니다.

---

## 작업 흐름

### Phase 1: 입력 및 출력 구조 파악

**입력 수집:**
`.ai/tasks/<TASK_ID>/10-output-plan.md` 파일을 읽고 다음을 확인합니다:

- 기술적 결정 사항 (4번 섹션)
- 화면-API 매핑 (5번 섹션)
- 핵심 테스트 시나리오 (8번 섹션)
- Step 2에서 결정 필요 사항 (8.3번)

**출력 구조 파악:**
[assets/templates/20-output-system-design.md](assets/templates/20-output-system-design.md)를 읽고 다음을 확인합니다:

- 채워야 할 섹션 목록
- 각 섹션에서 요구하는 정보 유형

> 💡 **원칙**: Step 1 출력을 입력으로 받아 설계로 변환합니다. 누락 없이 연결되어야 합니다.

### Phase 2: 다관점 분석 (템플릿 섹션별)

| 템플릿 섹션         | 담당 관점         | 수집할 정보                         |
| ------------------- | ----------------- | ----------------------------------- |
| 1. 설계 요약        | 전체              | 핵심 결정, 영향 범위                |
| 2. Step 1 입력 확인 | 전체              | 기술적 결정 반영, 갭 대응           |
| 3. 아키텍처 설계    | 아키텍트          | 구조, 매핑, 데이터 흐름, 인터페이스 |
| 4. 테스트 전략      | 테스트 전략가     | 경계, Mock, 시나리오 매핑           |
| 5. 파일별 구현 계획 | 구현 계획자       | 신규/수정 파일, 순서, 의존성        |
| 6. 코드 패턴 가이드 | 코드베이스 분석가 | 따라야 할 패턴, 금지 사항           |
| 7. 리뷰 체크포인트  | 전체              | 설계/구현 검증 기준                 |
| 8. 기술적 위험      | 전체              | 위험 요소, 대응 방안                |
| 9. 미결 사항        | 전체              | 결정 필요 항목                      |
| 10. 다음 단계       | 전체              | Step 3 주의사항                     |

### Phase 3: 코드베이스 분석

**코드베이스 분석가 관점:**

- 프로젝트 디렉토리 구조 파악
- 기존 코딩 컨벤션 확인
- 유사한 기존 기능의 구현 패턴 분석
- 재사용 가능한 컴포넌트/유틸 식별

**분석 대상:**

```
- 디렉토리 구조: src/, components/, hooks/, api/, types/
- 기존 패턴: 유사 기능의 구현 방식
- 컨벤션: 네이밍, 파일 구조, 상태 관리
- 의존성: 사용 중인 라이브러리
```

### Phase 4: 아키텍처 설계

**아키텍트 관점:**

1. **화면-컴포넌트 매핑**
   - Step 1의 화면-API 매핑을 컴포넌트 구조로 변환
   - 각 컴포넌트의 상태(loading, error, success) 정의

2. **데이터 흐름 설계**
   - 사용자 액션 → Hook → API → 상태 → UI 흐름 정의

3. **인터페이스 정의**
   - Swagger 기반 API 응답 타입
   - 컴포넌트 Props 타입
   - 상태 타입

### Phase 5: 테스트 전략 수립

**테스트 전략가 관점:**

Step 1의 "8.3 Step 2에서 결정 필요" 항목을 결정합니다:

| 결정 항목     | 고려 사항                           |
| ------------- | ----------------------------------- |
| 테스트 경계   | Unit vs Integration vs E2E 범위     |
| Mock 전략     | MSW, vi.mock, 테스트 더블 방식      |
| 테스트 데이터 | fixture, factory, faker 방식        |
| 커버리지 목표 | 비즈니스 로직 중심 vs 전체 커버리지 |

**시나리오 매핑:**

- Step 1의 TS-xxx 시나리오 → 테스트 파일 할당
- 각 시나리오의 테스트 유형(Unit/Integration/E2E) 결정

### Phase 6: 파일별 구현 계획 수립

**구현 계획자 관점:**

1. **신규 생성 파일 목록**
   - 의존성 순서대로 정렬 (types → api → hooks → components)
   - 각 파일의 역할과 관련 테스트 시나리오 명시

2. **수정 필요 파일 목록**
   - 기존 파일 중 수정이 필요한 파일
   - 수정 내용과 영향 범위

3. **코드 패턴 가이드**
   - 기존 코드에서 따라야 할 패턴 참조 경로
   - 프로젝트 금지 사항 목록

### Phase 7: 산출물 작성

- **템플릿**: [assets/templates/20-output-system-design.md](assets/templates/20-output-system-design.md)
- **출력 위치**: `.ai/tasks/<TASK_ID>/20-output-system-design.md`

---

## 경계 조건

| 허용                      | 금지                  | 이유                    |
| ------------------------- | --------------------- | ----------------------- |
| 코드베이스 구조/패턴 분석 | 구현 코드 작성        | 설계 단계는 분석만 수행 |
| Step 1 결정 사항 반영     | Step 1 결정 사항 변경 | Step 1은 이미 승인됨    |
| 테스트 전략 결정          | 테스트 코드 작성      | 구현은 Step 3에서 수행  |
| 기존 패턴 참조 명시       | 새로운 패턴 도입      | 일관성 유지             |
| -                         | 사용자 미확인 진행    | 설계는 반드시 승인 필요 |

---

## 완료 프로토콜

### 검증 체크리스트

모든 항목이 충족되어야 완료 가능:

- [ ] 10-output-plan.md 완전히 읽고 이해함
- [ ] Step 1 기술적 결정 사항이 설계에 반영됨
- [ ] Step 1 갭 분석 항목에 대한 설계 대응이 있음
- [ ] Step 1 테스트 시나리오(TS-xxx)가 테스트 전략에 매핑됨
- [ ] 코드베이스 구조와 패턴이 분석됨
- [ ] 아키텍처 설계가 기존 패턴과 일관됨
- [ ] 파일별 구현 계획이 의존성 순서로 정렬됨
- [ ] 코드 패턴 가이드가 구체적 참조 경로와 함께 작성됨
- [ ] 리뷰 체크포인트가 정의됨
- [ ] 20-output-system-design.md 작성 완료

---

## 주의사항

- **Step 1 연결 필수**: Step 1의 모든 결정 사항이 설계에 반영되어야 합니다.
- **기존 패턴 따르기**: 새로운 패턴보다 프로젝트의 기존 패턴을 따릅니다.
- **LLM 구현 가능 수준**: 설계는 LLM이 바로 구현할 수 있을 정도로 구체적이어야 합니다.
- **사람 리뷰 고려**: 리뷰어가 검증할 수 있는 체크포인트를 명시합니다.

## 출력 가이드

[assets/templates/20-output-system-design.md](assets/templates/20-output-system-design.md) 형식을 따르세요.

출력 파일 위치: `.ai/tasks/<TASK_ID>/20-output-system-design.md`

---

## 완료 처리

### 1. 사용자 확인 (필수)

체크리스트를 모두 만족했다면 사용자에게 확인합니다:

```
📋 Step 2 체크리스트 완료 확인:
- [ ] 10-output-plan.md 완전히 읽고 이해함
- [ ] Step 1 기술적 결정 사항 반영됨
- [ ] Step 1 테스트 시나리오 → 테스트 전략 매핑됨
- [ ] 코드베이스 구조/패턴 분석됨
- [ ] 아키텍처 설계 완료
- [ ] 파일별 구현 계획 작성됨
- [ ] 코드 패턴 가이드 작성됨
- [ ] 리뷰 체크포인트 정의됨
- [ ] 출력 파일 작성 완료

👉 Step 2를 완료 처리할까요?
```

> ⚠️ **사용자 승인 없이 다음 단계로 진행하지 마세요.**

### 2. 승인 후 처리

사용자가 승인하면 다음을 수행합니다:

#### Git 커밋

```bash
git add .ai/tasks/<TASK_ID>/20-output-system-design.md
git commit -m "feat/<TASK_ID>-[AI]: Completed Step 2 system design"
```

#### status.yaml 업데이트

```yaml
current_step: step-3
steps:
  step-2:
    status: completed
  step-3:
    status: pending
```

### 3. 다음 Step 안내

```
✅ Step 2 완료!

새 대화에서 다음 명령어로 Step 3을 시작하세요:
"<TASK_ID> 작업 이어서 진행해줘"
```
