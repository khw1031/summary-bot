[English](./README.md) | [한국어](./README.ko.md) | [日本語](./README.ja.md)

# Summary Bot

> 通过 Telegram 机器人发送 URL 或文本，LLM 自动进行摘要，并将结果以 Markdown 文件形式保存到 GitHub 仓库的 NestJS 应用程序

## 主要功能

- **URL 内容提取**: 发送网页 URL 后自动提取正文并生成摘要
- **X(Twitter) 推文支持**: 自动检测推文中分享的链接，提取原文并生成摘要
- **文本摘要**: 支持对非 URL 的普通文本进行摘要
- **双 LLM 提供者**: 支持 Claude 和 Gemini，Primary 失败时自动 Fallback
- **GitHub 自动保存**: 将摘要结果转换为 Markdown 文件并自动提交到 GitHub 仓库
- **知识图谱结构**: 摘要时同时分类上位/下位/关联概念，支持构建知识地图

## 架构

```
Telegram → TelegramUpdate (Handler)
               ↓
         SummaryService (Orchestrator)
          ↓         ↓          ↓
  ExtractorService  LlmService  GithubService
                    ↓      ↓
            ClaudeProvider  GeminiProvider
```

### 模块组成

| 模块 | 职责 |
|------|------|
| `TelegramModule` | 接收 Telegram Webhook 并处理用户交互 |
| `SummaryModule` | 摘要流水线编排及缓存管理 |
| `ExtractorModule` | 从 URL 提取内容 (article-extractor, raw fetch, oEmbed) |
| `LlmModule` | LLM 提供者管理及 Fallback 逻辑 |
| `GithubModule` | 生成 Markdown 并通过 GitHub API 保存文件 |
| `HealthModule` | 健康检查端点 (`GET /health`) |

## 处理流程

1. 用户通过 Telegram 发送 URL 或文本
2. `ExtractorService` 分析输入：
   - **URL 的情况**: 提取网页正文 (按 article-extractor → raw fetch → oEmbed 顺序尝试)
   - **X/Twitter URL 的情况**: 通过 fxtwitter API 解析推文中的链接，然后提取该 URL 的正文
   - **文本的情况**: 直接使用原文
3. `LlmService` 使用 LLM 对提取的内容进行摘要：
   - 生成韩文标题、英文 slug、分类、标签、关键词、概念分类、核心见解、Markdown 摘要
4. `GithubService` 将摘要结果转换为 Markdown 文件并自动提交到 GitHub
5. 通过 Telegram 发送摘要预览和 GitHub 链接
6. 用户可以通过 `删除` 按钮清除缓存，或在出错时通过 `重试` 按钮重新生成摘要

## 摘要结果结构

LLM 生成的摘要结果包含以下字段：

| 字段 | 说明 |
|------|------|
| `title` | 韩文标题 (15字以内) |
| `description` | 英文 kebab-case slug (用于文件名) |
| `category` | `Tech` / `AI` / `Business` / `Design` / `Productivity` / `Life` 之一 |
| `tags` | 3~5个英文标签 |
| `keywords` | 3~7个韩文核心关键词 |
| `concepts.upper` | 1~3个上位概念 |
| `concepts.lower` | 2~5个下位/细分概念 |
| `concepts.related` | 2~5个关联概念 |
| `insights` | 3~5条核心见解 (陈述性语句) |
| `summary` | Markdown 格式的详细摘要 |

## GitHub 保存格式

保存路径: `{SUMMARY_DIR}/YYYY-MM-DD-{slug}.md`

```markdown
---
title: "리액트 서버 컴포넌트의 이해"
date: 2025-02-10
category: Tech
tags: [react, server-components, nextjs]
keywords: [서버 컴포넌트, 클라이언트 컴포넌트, 번들 사이즈]
source: "https://example.com/article"
---

> 원문: https://example.com/article

## 요약 본문 ...

## 핵심 인사이트

- 인사이트 1
- 인사이트 2

## 키워드

`서버 컴포넌트` `클라이언트 컴포넌트` `번들 사이즈`

## 관련 개념

- **상위**: 웹 프레임워크, React 아키텍처
- **하위**: use client 지시어, 서버 전용 코드
- **연관**: 하이드레이션, Islands Architecture

> Auto-generated by Summary Bot on 2025-02-10
```

## 技术栈

- **运行时**: Node.js 20
- **框架**: NestJS 11
- **语言**: TypeScript 5.7
- **Telegram**: Telegraf + nestjs-telegraf (Webhook 模式)
- **LLM**: Anthropic Claude (`claude-sonnet-4-20250514`) / Google Gemini (`gemini-2.5-pro`)
- **GitHub**: Octokit REST API
- **内容提取**: @extractus/article-extractor
- **包管理器**: pnpm 9.15
- **部署**: Docker (Multi-stage build)

## 快速开始

### 前置条件

- Node.js 20+
- pnpm 9.15+
- Telegram Bot Token (在 [BotFather](https://t.me/BotFather) 中创建)
- LLM API 密钥 (Anthropic 或 Google AI 中至少一个)
- GitHub Personal Access Token (需要 repo 权限)

### 安装

```bash
# 克隆仓库
git clone <repository-url>
cd summary-bot

# 安装依赖
pnpm install
```

### 环境变量配置

将 `.env.example` 复制为 `.env` 并填写相应的值：

```bash
cp .env.example .env
```

| 环境变量 | 必填 | 说明 | 默认值 |
|---------|------|------|--------|
| `TELEGRAM_BOT_TOKEN` | O | Telegram Bot API 令牌 | - |
| `TELEGRAM_WEBHOOK_DOMAIN` | O | 接收 Webhook 的域名 (例: `https://example.com`) | - |
| `ANTHROPIC_API_KEY` | △ | Anthropic API 密钥 (使用 Claude 时必填) | - |
| `GEMINI_API_KEY` | △ | Google AI API 密钥 (使用 Gemini 时必填) | - |
| `GITHUB_TOKEN` | O | GitHub Personal Access Token | - |
| `GITHUB_REPO` | O | 保存摘要的 GitHub 仓库 (例: `owner/repo`) | - |
| `SUMMARY_DIR` | X | 仓库中摘要文件的目录 | `98-summaries` |
| `LLM_PROVIDER` | X | Primary LLM 提供者 (`claude` 或 `gemini`) | `gemini` |
| `PORT` | X | 服务器端口 | `3000` |

> LLM API 密钥必须配置所选 Primary 提供者的密钥，建议同时配置两者以支持 Fallback。

### 开发模式运行

```bash
# 开发服务器 (文件变更时自动重启)
pnpm start:dev

# 调试模式
pnpm start:debug
```

### 生产环境构建与运行

```bash
# 构建
pnpm build

# 生产环境运行
pnpm start:prod
```

### 使用 Docker 运行

```bash
# 构建镜像
docker build -t summary-bot .

# 运行容器
docker run -d \
  --name summary-bot \
  -p 3000:3000 \
  --env-file .env \
  summary-bot
```

### Webhook 配置

机器人启动后需要向 Telegram 注册 Webhook URL：

```
https://{TELEGRAM_WEBHOOK_DOMAIN}/api/telegram-webhook
```

`nestjs-telegraf` 在应用启动时会自动配置 Webhook。请在 `TELEGRAM_WEBHOOK_DOMAIN` 环境变量中指定可从外部访问的域名。

本地开发时可以使用 [ngrok](https://ngrok.com/) 等隧道工具：

```bash
ngrok http 3000
# 将输出的 HTTPS URL 设置为 TELEGRAM_WEBHOOK_DOMAIN
```

## 使用方法

1. 在 Telegram 中向机器人发送 URL 或文本私信。
2. 机器人显示"摘要中..."状态并处理内容。
3. 摘要完成后发送包含以下信息的预览消息：
   - 标题及分类/标签
   - 摘要预览 (300字)
   - 核心见解
   - 关键词
   - GitHub 链接
4. 可以点击 `删除` 按钮从缓存中移除并删除消息。
5. 出错时可以通过 `重试` 按钮重新生成摘要。

## 脚本

| 命令 | 说明 |
|--------|------|
| `pnpm start:dev` | 启动开发服务器 (watch 模式) |
| `pnpm start:debug` | 调试模式运行 |
| `pnpm build` | 生产环境构建 |
| `pnpm start:prod` | 生产环境运行 |
| `pnpm lint` | 运行 ESLint |
| `pnpm format` | Prettier 格式化 |

## 项目结构

```
src/
├── main.ts                      # NestJS 引导及 Webhook 配置
├── app.module.ts                # 根模块
├── config/
│   └── configuration.ts         # 环境变量配置
├── telegram/
│   ├── telegram.module.ts       # Telegram 模块 (Webhook 配置)
│   └── telegram.update.ts       # 消息处理器及内联按钮处理
├── summary/
│   ├── summary.module.ts        # Summary 模块
│   └── summary.service.ts       # 摘要流水线编排
├── extractor/
│   ├── extractor.module.ts      # Extractor 模块
│   └── extractor.service.ts     # URL/文本内容提取
├── llm/
│   ├── llm.module.ts            # LLM 模块
│   ├── llm.service.ts           # LLM 服务 (Fallback 逻辑)
│   ├── llm.interface.ts         # SummaryResult 接口
│   ├── prompts.ts               # LLM 系统/用户提示词
│   └── providers/
│       ├── claude.provider.ts   # Anthropic Claude 提供者
│       └── gemini.provider.ts   # Google Gemini 提供者
├── github/
│   ├── github.module.ts         # GitHub 模块
│   └── github.service.ts        # GitHub Markdown 保存
└── health/
    ├── health.module.ts         # Health 模块
    └── health.controller.ts     # GET /health 端点
```

## 许可证

MIT
